---
category: post
title:  "ðŸ“šC++ Refreshing"
date:   "2021-01-16"
size: 4
visible: 1
---

Refresh my C++ 11 brain and upgrade to 17...

# Cheatsheet
+ nullptr not NULL
+ constexpr e.g. fibonacci for compile time
+ if/switch ( tmp variable ; ...)
+ std::intializer_list<int> -> { 1, 2, 3} for sizable input
+ tuple and destructor auto [x, y, z] = std::make_tuple<int, double, std::string\>(...)
+ get auto type: std::is_same<decltype(x), int>::value
+ if constexpr( compile time check) {...
+ using > typedef
+ auto can be return value for template and can be parameters for functionals
+ default template type template<typename T = int, typename U = int \>
+ skipped due to sick of more meta programming skill...
+ constructor can call other constructor
+ inherit constructor with using Base::Base;
+ java flavor override and final: virtual foo() override; or virtual foo() final;
+ explicitly constructors: Magic()= default; Magic(const Magic& )=delete; Magic& operator=(const Magic &)=delete;
+ lambda: [&](args) -> returnee {...} [] can be empty or values that want to capture in function when contructing lambda
+ use std::function<...> instead of pointer
+ bind function: std::bind(foo, std::placeholders::_1, 1,2) new function takes only one arg
+ T&& extends the life of rvalue and can change it. while T&& itself as ref is lvalue.
+ vec.push_back(std::move(str))
