(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{"8hLB":function(e,t,a){"use strict";var n=a("q1tI"),o=a.n(n),s=(a("Wbzz"),a("Bl7J"));t.a=function(e){return o.a.createElement(s.a,Object.assign({},e,{icon:"post"}))}},SwdP:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return r})),a.d(t,"default",(function(){return b}));var n=a("zLVn"),o=(a("q1tI"),a("7ljp")),s=a("8hLB"),r={},c={_frontmatter:r},l=s.a;function b(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(o.b)(l,Object.assign({},c,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Why would ppl design API like this?"),Object(o.b)("h1",null,"Motivation"),Object(o.b)("p",null,"Like opengl, these low level api is very tedious and old. It's not aiming for usability but rather performance and comprehensive capability. However, I'm still surprised that we don't even have a wrapper API in ffmpeg? Let's use boilerplate snippet to fix."),Object(o.b)("p",null,'This is for whoever "Just Want to Load Video and Get the RGBA! Frame By Frame".'),Object(o.b)("h1",null,"FFMPEG 101"),Object(o.b)("p",null,"Each video file or ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"*.mp4")," is composed of video stream, audio stream. For each stream, they are stored as ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"packet")," by ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"packet")," or ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"blob")," by ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"blog"),". However, these ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"packet")," are not straightforward to view as a frame of picture. You need to decode it to see the real RGBA images which is called ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"frame"),". ",Object(o.b)("code",Object.assign({parentName:"p"},{className:"language-text"}),"frame")," has different format other than RGBA. Most of cases, you need to convert them, e.g. from YUV (which stores like YYYYYYY....UUUUU.....VVVVVVV....) to RGBA (RGBARGBARGBA...)."),Object(o.b)("h1",null,"Snippets"),Object(o.b)("p",null,"Like opengl's hello world, ffmpeg's hello world is neither mercy for beginner üòÅ. "),Object(o.b)("p",null,"The process is:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"load file (with meta information)"),Object(o.b)("li",{parentName:"ol"},"find decoder"),Object(o.b)("li",{parentName:"ol"},"find streams"),Object(o.b)("li",{parentName:"ol"},"decode streams"),Object(o.b)("li",{parentName:"ol"},"convert frame"),Object(o.b)("li",{parentName:"ol"},"do whatever to your RGBA buffer"),Object(o.b)("li",{parentName:"ol"},"free resources")),Object(o.b)("h1",null,"Try It Out!"),Object(o.b)("p",null,"First we need start a cpp project. With Nix this is ",Object(o.b)("a",Object.assign({parentName:"p"},{href:""}),"simple"),"."),Object(o.b)("h1",null,"Header Only Wrapper?"),Object(o.b)("p",null,"TODO:"),Object(o.b)("h1",null,"Bonus"),Object(o.b)("p",null,"What if performance is not my concern? and I just want to hack something..."))}b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-posts-2022-02-18-ffmpeg-snippet-mdx-6d402e752eed687e66d5.js.map